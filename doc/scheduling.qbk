[/
          Copyright Oliver Kowalke 2013.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:scheduling Scheduling]

Fibers are managed by a scheduler which coordinates the sequence of fibers
running or waiting.
Each thread is required to have its own scheduler. By default, __boost_fiber__
creates for each thread a scheduler ([class_link round_robin]).

A fiber-scheduler must implement interface __algo__.
You are explicitly permitted to code your own __algo__ subclass, and to pass
it to [function_link set_scheduling_algorithm].

        void thread_fn() {
            my_fiber_scheduler mfs;
            boost::fibers::set_scheduling_algorithm( & mfs);
            ...
        }


[class_heading sched_algorithm]

        #include <boost/fiber/algorithm.hpp>

        struct sched_algorithm {
            virtual ~sched_algorithm() {}

            virtual void awakened( fiber_context *) = 0;

            virtual fiber_context * pick_next() = 0;
        };

[member_heading sched_algorithm..awakened]

        virtual void awakened( fiber_context * f) = 0;

[variablelist
[[Effects:] [Marks fiber `f`, to be ready to run.]]
]

[member_heading sched_algorithm..pick_next]

        virtual fiber_context * pick_next() = 0;

[variablelist
[[Effects:] [Depending on the scheduling algorithm, this function returns the
fiber which is to be resumed next.]]
]

[member_heading sched_algorithm..priority]

        virtual void priority( fiber_context *, int) noexcept = 0;

[variablelist
[[Effects:] [Resets the priority of fiber `f`.]]
]


To prevent the library from heap-allocating a default scheduler for a given
thread, that thread must call [function_link set_scheduling_algorithm] before
any other __boost_fiber__ entry point.

        void thread_fn()
        {
            my_fiber_scheduler mfs;
            boost::fibers::set_scheduling_algorithm( & mfs);
            ...
        }

A fiber-scheduler must implement interface __algo__. __boost_fiber__ provides one
scheduler: [class_link round_robin].

You are explicitly permitted to code your own __algo__ subclass, and to pass
it to [function_link set_scheduling_algorithm].


[class_heading sched_algorithm]

        #include <boost/fiber/algorithm.hpp>

        struct sched_algorithm
        {
            virtual ~sched_algorithm() {}

            virtual void awakened( detail::worker_fiber *) = 0;

            virtual detail::worker_fiber * pick_next() = 0;

            virtual void priority( detail::worker_fiber *, int) noexcept = 0;
        };

[member_heading sched_algorithm..awakened]

        virtual void awakened( detail::worker_fiber * f) = 0;

[variablelist
[[Effects:] [Marks fiber `f`, to be ready to run.]]
]

[member_heading sched_algorithm..pick_next]

        virtual detail::worker_fiber * pick_next() = 0;

[variablelist
[[Effects:] [Depending on the scheduling algorithm, this function returns the
fiber which is to be resumed next.]]
]

[member_heading sched_algorithm..priority]

        virtual void priority( detail::worker_fiber *, int) noexcept = 0;

[variablelist
[[Effects:] [Resets the priority of fiber `f`.]]
]


[class_heading round_robin]

This class implements __algo__ and schedules fibers in round-robin fashion
(ignores `fiber::priority()`).

[info The example section provides a scheduler used for migrating fibers
(work-stealing) between threads (different schedulers).]


[endsect]
