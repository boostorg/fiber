<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Condition Variables</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Fiber">
<link rel="up" href="../synchronization.html" title="Synchronization">
<link rel="prev" href="mutex_types.html" title="Mutex Types">
<link rel="next" href="barriers.html" title="Barriers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="mutex_types.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../synchronization.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="barriers.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section fiber_synchronization_conditions">
<div class="titlepage"><div><div><h3 class="title">
<a name="fiber.synchronization.conditions"></a><a class="link" href="conditions.html" title="Condition Variables">Condition Variables</a>
</h3></div></div></div>
<h5>
<a name="fiber.synchronization.conditions.h0"></a>
        <span><a name="fiber.synchronization.conditions.synopsis"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.synopsis">Synopsis</a>
      </h5>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">cv_status</span><span class="special">;</span>
<span class="special">{</span>
    <span class="identifier">no_timeout</span><span class="special">,</span>
    <span class="identifier">timeout</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">condition_variable</span><span class="special">;</span>
<span class="keyword">class</span> <span class="identifier">condition_variable_any</span><span class="special">;</span>
</pre>
<p>
        The class <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        provides a mechanism for one fiber to wait for notification on <code class="computeroutput"><span class="identifier">condition_variable</span></code>. When the fiber awakens
        from the wait, then it checks to see if the appropriate condition is now
        true, and continues if so. If the condition is not true, then the fiber calls
        <code class="computeroutput"><span class="identifier">wait</span></code> again to resume waiting.
        In the simplest case, this condition is just a boolean variable:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">data_ready</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">process_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">wait_for_data_to_process</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// Oliver: how about a boost::fibers::mutex::scoped_lock?</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx</span><span class="special">);</span>
    <span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">data_ready</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">process_data</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Notice that the <code class="computeroutput"><span class="identifier">lk</span></code> is passed
        to <code class="computeroutput"><span class="identifier">wait</span></code>: <code class="computeroutput"><span class="identifier">wait</span></code>
        will atomically add the fiber to the set of fibers waiting on the condition
        variable, and unlock the mutex. When the fiber is awakened, the mutex will
        be locked again before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
        returns. This allows other fibers to acquire the mutex in order to update
        the shared data, and ensures that the data associated with the condition
        is correctly synchronized.
      </p>
<p>
        Oliver: is it important to state "atomically" in the paragraph
        above?
      </p>
<p>
        In the meantime, another fiber sets the condition to <code class="computeroutput"><span class="keyword">true</span></code>,
        and then calls either <code class="computeroutput"><span class="identifier">notify_one</span></code>
        or <code class="computeroutput"><span class="identifier">notify_all</span></code> on the condition
        variable to wake one waiting fiber or all the waiting fibers respectively.
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">retrieve_data</span><span class="special">();</span>
<span class="keyword">void</span> <span class="identifier">prepare_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">prepare_data_for_processing</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">retrieve_data</span><span class="special">();</span>
    <span class="identifier">prepare_data</span><span class="special">();</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx</span><span class="special">);</span>
        <span class="identifier">data_ready</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Note that the same mutex is locked before the shared data is updated, but
        that the mutex does not have to be locked across the call to <code class="computeroutput"><span class="identifier">notify_one</span></code>.
      </p>
<h5>
<a name="fiber.synchronization.conditions.h1"></a>
        <span><a name="fiber.synchronization.conditions.class__code__phrase_role__identifier__condition_variable__phrase___code_"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.class__code__phrase_role__identifier__condition_variable__phrase___code_">Class
        <code class="computeroutput"><span class="identifier">condition_variable</span></code></a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">condition</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">enum</span> <span class="identifier">cv_status</span>
<span class="special">{</span>
    <span class="identifier">no_timeout</span> <span class="special">=</span> <span class="number">1</span><span class="special">,</span>
    <span class="identifier">timeout</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">condition_variable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">condition_variable</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">condition_variable</span><span class="special">();</span>

    <span class="identifier">condition_variable</span><span class="special">(</span> <span class="identifier">condition_variable</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">condition_variable</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">condition_variable</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span> <span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">predicate</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span> <span class="special">&gt;</span>
    <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">clock_type</span><span class="special">::</span><span class="identifier">time_point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">clock_type</span><span class="special">::</span><span class="identifier">time_point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <span class="identifier">condition_variable</span> <span class="identifier">condition_variable_any</span><span class="special">;</span>
</pre>
<h5>
<a name="fiber.synchronization.conditions.h2"></a>
        <span><a name="fiber.synchronization.conditions.constructor"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.constructor">Constructor</a>
      </h5>
<pre class="programlisting"><span class="identifier">condition_variable</span><span class="special">()</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Creates the object.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
</dl>
</div>
<h5>
<a name="fiber.synchronization.conditions.h3"></a>
        <span><a name="fiber.synchronization.conditions.destructor"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.destructor">Destructor</a>
      </h5>
<pre class="programlisting"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              All fibers waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call to
              <code class="computeroutput"><span class="identifier">notify_one</span></code> or <code class="computeroutput"><span class="identifier">notify_all</span></code> (though the respective
              calls to <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>
              need not have returned).
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Destroys the object.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              Oliver: what can we expect if one or more of the fibers waiting on
              <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
              have not yet been notified? They go into limbo?
            </p></dd>
</dl>
</div>
<h5>
<a name="fiber.synchronization.conditions.h4"></a>
        <span><a name="fiber.synchronization.conditions.member_function__code__phrase_role__identifier__notify_one__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.member_function__code__phrase_role__identifier__notify_one__phrase__phrase_role__special______phrase___code_">Member
        function <code class="computeroutput"><span class="identifier">notify_one</span><span class="special">()</span></code></a>
      </h5>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              If any fibers are currently <span class="emphasis"><em>blocked</em></span> waiting on
              <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
              in a call to <code class="computeroutput"><span class="identifier">wait</span></code>,
              <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>, unblocks one of those
              fibers.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              It is arbitrary which waiting fiber is resumed.
            </p></dd>
</dl>
</div>
<h5>
<a name="fiber.synchronization.conditions.h5"></a>
        <span><a name="fiber.synchronization.conditions.member_function__code__phrase_role__identifier__notify_all__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.member_function__code__phrase_role__identifier__notify_all__phrase__phrase_role__special______phrase___code_">Member
        function <code class="computeroutput"><span class="identifier">notify_all</span><span class="special">()</span></code></a>
      </h5>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              If any fibers are currently <span class="emphasis"><em>blocked</em></span> waiting on
              <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
              in a call to <code class="computeroutput"><span class="identifier">wait</span></code>,
              <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>, unblocks all of those
              fibers.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              This is why a waiting fiber must <span class="emphasis"><em>also</em></span> check for
              the desired program state using a mechanism external to the <code class="computeroutput"><span class="identifier">condition_variable</span></code>, and retry the
              wait until that state is reached. A fiber waiting on a <code class="computeroutput"><span class="identifier">condition_variable</span></code> might well wake
              up a number of times before the desired state is reached.
            </p></dd>
</dl>
</div>
<h5>
<a name="fiber.synchronization.conditions.h6"></a>
        <span><a name="fiber.synchronization.conditions.templated_member_function__code__phrase_role__identifier__wait__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.templated_member_function__code__phrase_role__identifier__wait__phrase__phrase_role__special______phrase___code_">Templated
        member function <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code></a>
      </h5>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber, and either no other fiber is currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
              or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the calls
              to <code class="computeroutput"><span class="identifier">wait</span></code> in all the
              fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value as
              <code class="computeroutput"><span class="identifier">lk</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
              for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
              Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber. The
              fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>, or spuriously. When the fiber is
              unblocked (for whatever reason), the lock is reacquired by invoking
              <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
              before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
              returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              Member function using <code class="computeroutput"><span class="identifier">pred</span></code>
              as-if
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">fiber_exception</span></code> if
              an error occurs. <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
              if the wait was interrupted by a call to <code class="computeroutput"><span class="identifier">fiber</span><span class="special">::</span><span class="identifier">interrupt</span><span class="special">()</span></code> on the <code class="computeroutput"><span class="identifier">fiber</span></code>
              object associated with the current fiber of execution.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              Oliver: What does the Precondition mean? I can provide an explanation
              once I understand it myself, but I do not yet understand it.
            </p></dd>
</dl>
</div>
<h5>
<a name="fiber.synchronization.conditions.h7"></a>
        <span><a name="fiber.synchronization.conditions.templated_member_function__code__phrase_role__identifier__wait_until__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.templated_member_function__code__phrase_role__identifier__wait_until__phrase__phrase_role__special______phrase___code_">Templated
        member function <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code></a>
      </h5>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span> <span class="special">&gt;</span>
<span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">clock_type</span><span class="special">::</span><span class="identifier">time_point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">clock_type</span><span class="special">::</span><span class="identifier">time_point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber, and either no other fiber is currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
              or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the calls
              to <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>
              in all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value as
              <code class="computeroutput"><span class="identifier">lk</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
              for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
              Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber. The
              fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>, when the time as reported by <code class="computeroutput"><span class="identifier">clock_type</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span></code>
              would be equal to or later than the specified <code class="computeroutput"><span class="identifier">timeout_time</span></code>,
              or spuriously. When the fiber is unblocked (for whatever reason), the
              lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also reacquired
              by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
              if the function exits with an exception. Member function using <code class="computeroutput"><span class="identifier">pred</span></code> as-if
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> <span class="special">==</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">timeout_time</span><span class="special">)</span> <span class="special">)</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
            </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">fiber_exception</span></code> if
              an error occurs. <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
              if the wait was interrupted by a call to <code class="computeroutput"><span class="identifier">fiber</span><span class="special">::</span><span class="identifier">interrupt</span><span class="special">()</span></code> on the <code class="computeroutput"><span class="identifier">fiber</span></code>
              object associated with the current fiber of execution.
            </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="keyword">false</span></code> if the call is returning
              because the time specified by <code class="computeroutput"><span class="identifier">timeout_time</span></code>
              was reached, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              Oliver: but that disagrees with the example above?
            </p></dd>
</dl>
</div>
<h5>
<a name="fiber.synchronization.conditions.h8"></a>
        <span><a name="fiber.synchronization.conditions.templated_member_function__code__phrase_role__identifier__wait_for__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="conditions.html#fiber.synchronization.conditions.templated_member_function__code__phrase_role__identifier__wait_for__phrase__phrase_role__special______phrase___code_">Templated
        member function <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code></a>
      </h5>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">LockType</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">LockType</span> <span class="special">&amp;</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber, and either no other fiber is currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
              or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the calls
              to <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code>
              in all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value as
              <code class="computeroutput"><span class="identifier">lk</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
              for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
              Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber. The
              fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>, when the time as reported by <code class="computeroutput"><span class="identifier">clock_type</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">timeout_duration</span><span class="special">()</span></code> would be equal to or later than the
              specified time point, or spuriously. When the fiber is unblocked (for
              whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
              before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
              returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              Member function using <code class="computeroutput"><span class="identifier">pred</span></code>
              as-if
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> <span class="special">==</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">lt</span><span class="special">,</span> <span class="identifier">timeout_duration</span><span class="special">)</span> <span class="special">)</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
            </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
              current fiber.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">fiber_exception</span></code> if
              an error occurs. <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
              if the wait was interrupted by a call to <code class="computeroutput"><span class="identifier">fiber</span><span class="special">::</span><span class="identifier">interrupt</span><span class="special">()</span></code> on the <code class="computeroutput"><span class="identifier">fiber</span></code>
              object associated with the current fiber of execution.
            </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="keyword">false</span></code> if the call is returning
              because the time specified by <code class="computeroutput"><span class="identifier">timeout_time</span></code>
              was reached, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
            </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
              Oliver: but that disagrees with the example above?
            </p></dd>
</dl>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013 Oliver Kowalke<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="mutex_types.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../synchronization.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="barriers.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
